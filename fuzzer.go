package notionFuzz

// commands go-fuzz and go-fuzz-build are in ~/go/src/github.com/dvy"""/go-fuzz

import (
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	
	"github.com/notion/bastion/asciicast"
	"github.com/notion/bastion/config"
)

// import "github.com/notion/bastion/tree/master/config"
// fuzz Load( ) func in bastion/config/main.go

// Cast is the base of the asciicast formate
type Cast struct {
	Header *Header
	Frames []*Frame
}

// Header corresponds to the asciicast v2 header protocol
type Header struct {
	Version       int               `json:"version"`
	Width         int               `json:"width"`
	Height        int               `json:"height"`
	Timestamp     int64             `json:"timestamp,omitempty"`
	Duration      float64           `json:"duration,omitempty"`
	IdleTimeLimit float64           `json:"idle_time_limit,omitempty"`
	Command       string            `json:"command,omitempty"`
	Title         string            `json:"title,omitempty"`
	Env           map[string]string `json:"env,omitempty"`
	Theme         map[string]string `json:"theme,omitempty"`
}

// Frame is the base frame from an asciicast
type Frame struct {
	Time   float64
	Event  string
	Data   string
	Author string
}

var (
	monAddr      = flag.String("mon.addr", ":9501", "The address to listen for prom connections on")
	webAddr      = flag.String("web.addr", ":8080", "The address to listen for http connections on")
	sshAddr      = flag.String("ssh.addr", ":5222", "The address to listen for ssh connections on")
	sshProxyAddr = flag.String("ssh.proxy.addr", "localhost:22222", "The address to listen for ssh proxy connections on")
	forceCerts   = flag.Bool("ssh.force-certs", false, "Force certificate generation")
)

func Fuzz(data []byte) int {

	// Data is a random input generated by go-fuzz, note that in most cases it is invalid.
	// The function must return 1 if the fuzzer should increase priority of the given input during subsequent fuzzing (for example, the input is lexically correct and was parsed successfully); -1 if the input must not be added to corpus even if gives new coverage; and 0 otherwise; other values are reserved for future use.

	 return fuzzLoadFunc(data)

//	return fuzzUnmarshall(data)

	// another idea is think about how http/ssh messages are formatted on the wire (json, http) so when youre imitating a client you can send this over the network and youre sure it will be parsed upon receipt
	// start this fuzzing with valid things and other byte streams that are close (in the format of) to what it would accept but slightly wrong.

}

func fuzzMain(data []byte, hostname string, port int) int {
	url := hostname + ":" + string(port)
	resp, err := http.Get(url)

	if err != nil {
		if resp.StatusCode != 401 {
			return 1
		}
		return 0
	}
	return 1
}

func fuzzUnmarshall(data []byte) int {
	// this should crash if the string doesn't have a newline bc of line 83 in parser.go file (assumes there is newline so .split will return slice of length 1)
	// i think this code also assumes that the frame(s) can be sliced??
	inputString := string(data)
	cast, err := asciicast.UnmarshalCast(inputString)
	if err != nil {
		return 0
	}
	if cast == nil {
		return 1
	}

	fileFormat, err := cast.Marshal()
	if err != nil {
		return 0
	}
	if &fileFormat == nil {
		return 1
	}
	return 0
}

func fuzzLoadFunc(data []byte) int {

	// fuzzer return 1 when/if program returns nil
	// fuzzer should return 0 when/if program returns non-nil env variable.
	flag.Parse()

	//write byte stream into config.yml file and then call load func with predetermined inputs that make sense
	err := ioutil.WriteFile("bastion/config/config.yml", data, 0644)
	if err != nil {
		// can't successfully write byte stream to file
		return -1
	}

	env := config.Load(*forceCerts, *webAddr, *sshAddr, *sshProxyAddr, *monAddr)
	if env == nil {
		return 1
	}
	return 0

}

func main() {
	var s []byte
	// s = make([]byte, 5, 5)
	s = []byte{5, 150, 9, 0, 1, 1, 1, 1, 1, 1, 1}
	// s = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0}
	fmt.Println(s)
	Fuzz(s)
}

// inptus to Load() when you run it locally via steps in the README on Github:
// false
// :8080
// :5222
// localhost:22222
// :9501
